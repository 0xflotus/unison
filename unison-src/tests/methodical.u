-- This file is meant to test all the cases of the runtime.
-- Tests in this file should be as small as possible.

-- LITERALS
ln = 10
li = +10
lf = 10.0
lt = "text"
lb = true
sn = [1,2,3,4,5,6,ln]

-- Make sure we can compile all literals
> (ln, li, lf, lt, lb, sn)

-- LET
c0 =
  a = 1000
  b = 100
  c = 10
  d = 1
  [a + b + c + d, b + c + d, c + d, d]

-- Make sure we can push values onto the stack and reference them as expected
> c0

-- FUNCTION APPLICATION. There are several cases to check:
--  * Exact application, underapplication, overapplication
--  * Closure formation (used by data types and builtins) vs specialization
--  * Overapplication yielding a request

fn p1 p2 p3 p4 = [p1, p2, p3, p4]

exact =
  p1 = 1
  p2 = 2
  fn p1 p2 3 4

underapply0 =
  f = fn 1
  f 2 3 4

underapply1 =
  f = fn 1 2
  f 3 4

underapply2 =
  f = fn 1 2 3
  f 4

fn2 p1 p2 =
  f p3 p4 = [p1, p2] ++ [p3, p4]
  f

exact1 =
  f = fn2 1 2
  f 3 4

overapply1 = fn2 1 2 3 4

overapply2 =
  f = fn2 1 2 3
  f 4

overapplyN =
  id x = x
  id id id id id 99

> (exact, underapply0, underapply1, underapply2, exact1, overapply1, overapply2)
> overapplyN

-- Now check exact and underapply cases for constructors

type Woot = Woot Nat Nat Nat Nat

use Woot Woot

exactt = Woot 1 2 3 4

underapply0t =
  p1 = 1
  f = Woot p1
  f 2 3 4

underapply1t =
  p2 = 2
  f = Woot 1 p2
  f 3 4

underapply2t =
  f = Woot 1 2 3
  f 4

> (exactt, underapply0t, underapply1t, underapply2t)


-- PATTERN MATCHING

pat1 x y p = case p of x0 -> (x0, x, y, p)
> pat1 0 1 (2, 3)

pat2 x y p = case p of _ -> (x, y, p)
> pat2 0 1 "hi"

pat3 x y p = case p of (x, y) -> (y, x)
> pat3 0 1 (2, 3)

pat4 x y p = case p of (p1, _) -> (x, y, p1)
> pat4 0 1 (2, 3)

pat5 x y p = case p of (_, p2) -> (x, y, p2)
> pat5 0 1 (3, 2)

pat6 x y p = case p of (p1, _) -> (x + y : Nat, p1)
> pat6 1 2 (3, 4)

pat7 x y p = case p of
  (p1, _) | p1 == 9 -> (x + y : Nat, p1)
  (p1, _) | true    -> (0, p1)
> pat7 1 2 (20, 10)

-- ABILITIES

ability A where
  woot : {A} Nat

unA w = case w of
  {a} -> a
  {A.woot -> k} -> handle unA in k 10

-- This verifies that the continuation captures local variables
a1 = handle unA in
  x = 42
  y = A.woot
  x

> a1 -- should be 42

-- Now check overapply cases for abilities

-- ability Zing where
--   zing : Nat -> {Zing} (Nat -> Nat)
--   zing2 : Nat -> Nat ->{Zing} (Nat -> Nat -> [Nat])
--
-- unzing z = case z of
--   {a} -> a
--   {Zing.zing n -> k} -> handle unzing in k (x -> x `drop` n)
--   {Zing.zing2 n1 n2 -> k} -> handle unzing in k (n3 n4 -> [n1, n2, n3, n4])
--
-- exacth = handle unzing in
--   f = Zing.zing 3
--   f 20 + 1
--
-- overapplyh = handle unzing in
--   Zing.zing 3 20 + 1
--
-- -- SEQUENCES with abilities
--
-- sequence1 = handle unzing in [Zing.zing 1 4]
--
-- -- gives incorrect results
-- sequence2 = handle unzing in [Zing.zing 1 4, Zing.zing 1 4]
--
-- -- bombs
-- sequence3 = handle unzing in [Zing.zing 1 4, Zing.zing 2 4, Zing.zing 3 4, Zing.zing 4 4]
--
-- > (sequence1, sequence2, sequence3)
--
-- -- Overapply of requests
--
-- overapplyh2 = handle unzing in
--   Zing.zing2 1 2 3 4
--
-- overapplyh3a = handle unzing in
--   Zing.zing2 1 2 3 4 ++ [5]
--
-- -- these bomb
--
-- overapplyh3b = handle unzing in Zing.zing2 1 2 3 4 ++ [5, Zing.zing 2 8]
--
-- overapplyh3c = handle unzing in Zing.zing2 1 2 3 4 ++ [5, Zing.zing 2 7 + 1]
--
-- > (exacth, overapplyh, overapplyh2, overapplyh3a, overapplyh3b, overapplyh3c)
