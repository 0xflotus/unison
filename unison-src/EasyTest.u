use Test Success Status Report Test Scope
use Test.Status Failed Expected Unexpected Pending
use Test.Success Passed Proved
use Test.Report Report
use Test.Test Test
use Test passed proved failed expected unexpected pending finished label
use Test.Scope Scope
use Sequence flatMap

type Test.Success = Passed Nat | Proved

type Test.Status = Failed 
                 | Expected Test.Success
                 | Unexpected Test.Success
                 | Pending

-- Current scope together with accumulated test report.
type Test.Report = Report (Trie Text [Test.Status])

type Test.Test = Test (Test.Scope -> Test.Report)

unique type Test.Scope = Scope [Text]

foldSuccess : (Nat -> r) -> r -> Success -> r
foldSuccess passed proved s = case s of
  Passed n -> passed n
  Proved -> proved

foldStatus : r -> (Success -> r) -> (Success -> r) -> r -> Status -> r
foldStatus failed expected unexpected pending status = case status of 
  Failed -> failed
  Expected s -> expected s
  Unexpected s -> unexpected s
  Pending -> pending
    
foldReport : (Trie Text [Test.Status] -> r) -> Report -> r
foldReport k r = case r of Report t -> k t

foldScope : ([Text] -> r) -> Scope -> r
foldScope k s = case s of Scope ss -> k ss

Scope.cons : Text -> Scope -> Scope
Scope.cons n = foldScope (Scope . Sequence.cons n)

-- Basic building blocks of tests
Test.finished : Status -> Test
Test.finished st = 
  Test (Report . foldScope (sc -> Trie.singleton sc [st]))

Test.failed : Test
Test.failed = finished Failed

Test.proved : Test
Test.proved = finished <| Expected Proved

Test.passed : Test
Test.passed = finished . Expected <| Passed 1

Test.passedUnexpectedly : Test
Test.passedUnexpectedly = finished . Unexpected <| Passed 1

Test.provedUnexpectedly : Test
Test.provedUnexpectedly = finished <| Unexpected Proved

-- Basic test combinators

Test.modifyStatus : (Status -> Status) -> Test -> Test
Test.modifyStatus f t =
  case t of Test k -> Test (foldReport (Report . map (map f)) . k)

Test.label : Text -> Test -> Test
Test.label n t = case t of
  Test.Test.Test k -> Test (scope -> k <| Scope.cons n scope)

use Test.Report combine

(Test.&&) : Test -> Test -> Test
(Test.&&) a b = case (a,b) of
  (Test k1, Test k2) ->
    Test (
      scope -> 
        let r1 = k1 scope
            r2 = k2 scope
            combine r1 r2)

Test.passedWith : Text -> Test
Test.passedWith m = label m passed

Test.provedWith : Text -> Test
Test.provedWith m = label m proved

Test.failedWith : Text -> Test
Test.failedWith m = Test.label m Test.failed

-- Report combinators

Test.Report.combine : Report -> Report -> Report
Test.Report.combine r1 r2 = case (r1, r2) of
  (Test.Report.Report t1, Test.Report.Report t2) ->
    Report <| Trie.unionWith (Sequence.++) t1 t1

Test.Report.empty : Report
Test.Report.empty = Report empty

Test.Report.toCLIResult : Report -> [Test.Result]
Test.Report.toCLIResult r =
  descend scope p = case p of (k, t) -> 
    go ((if scope != "" then (scope ++ ".") else "") ++ k) t
  convert : Text -> Test.Status -> Test.Result
  convert scope s = case s of 
    Test.Status.Failed -> Test.Result.Fail scope
    Test.Status.Expected (Test.Success.Passed n) ->
      Test.Result.Ok (scope ++ " : Passed " ++ Nat.toText n ++ " tests.")
    Test.Status.Expected (Test.Success.Proved) ->
      Test.Result.Ok (scope ++ " : Proved.")
  go : Text -> Trie Text [Test.Status] -> [Test.Result]
  go scope t = 
    rest = flatMap (descend scope) (Map.toSequence (tail t))
    case head t of
      Optional.Some statuses -> 
        map (convert scope) statuses ++ rest
      Optional.None -> rest
  case r of Test.Report.Report t -> go "" t

Test.report : Test -> Report
Test.report t = case t of Test k -> k (Scope [])

-- Running tests

Test.run : Test -> [Test.Result]
Test.run = Test.Report.toCLIResult . Test.report

Test.runAll : [Test] -> [Test.Result]
Test.runAll = flatMap Test.run

-- Status combinators

Status.combine : Test.Status -> Test.Status -> Test.Status
Status.combine s1 s2 = case (s1, s2) of
  (_, Pending) -> Pending
  (Pending, _) -> Pending
  (Failed, _) -> Failed
  (_, Failed) -> Failed
  (Expected a, Expected b) -> Expected (Success.combine a b)

Status.pending : Test.Status -> Test.Status
Status.pending s = case s of
  Failed -> Pending
  Expected s -> Unexpected s
  Unexpected s -> Pending
  Pending -> Pending

-- Make a test pending
Test.pending : Test -> Test
Test.pending = modifyStatus Status.pending 

Test.modifyScope : (Scope -> Scope) -> Test -> Test
Test.modifyScope f t = case t of Test k -> Test (k . f)

Success.combine s1 s2 = case (s1, s2) of
  (Passed n, Passed m) -> Passed (n + m)
  (Passed n, Proved) -> Passed n
  (Proved, Passed n) -> Passed n
  (Proved, Proved) -> Proved

-- Arbitrary data

type Gen a = Gen (Nat -> [a])

Gen.nats : Gen Nat
Gen.nats = Gen (n -> Sequence.range 0 n)

Gen.booleans : Gen Boolean
Gen.booleans = Gen (n -> Sequence.take n [false, true])

use Universal <

Gen.listsOf : Gen a -> Gen [a]
Gen.listsOf g =
  Gen (n -> Sequence.unfold (Gen.generate n g, 0) 
                            (s -> case s of 
                                    (as,m) | m < n ->
                                      Some (Sequence.take m as,(as, m + 1))
                                    _ -> None))

Gen.generate : Nat -> Gen a -> [a]
Gen.generate n g = case g of Gen.Gen f -> f n

test> Test.run (Test.provedWith "fef")

