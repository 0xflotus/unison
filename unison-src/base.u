Remote.transfer : Node -> Remote Unit;
Remote.transfer node = Remote.at node unit;

Remote.map : ∀ a b . (a -> b) -> Remote a -> Remote b;
Remote.map f = Remote.bind (f `then` Remote.pure);

then : ∀ a b c . (a -> b) -> (b -> c) -> a -> c;
then f1 f2 x = f2 (f1 x);

Optional.map : ∀ a b . (a -> b) -> Optional a -> Optional b;
Optional.map f = Optional.fold None (f `then` Some);

Optional.bind : ∀ a b . (a -> Optional b) -> Optional a -> Optional b;
Optional.bind f = Optional.fold None f;

Optional.pure : ∀ a . a -> Optional a;
Optional.pure = Some;

Either.map : ∀ a b c . (b -> c) -> Either a b -> Either a c;
Either.map f = Either.fold Left (f `then` Right);

Either.pure : ∀ a b . b -> Either a b;
Either.pure = Right;

Either.bind : ∀ a b c . (b -> Either a c) -> Either a b -> Either a c;
Either.bind = Either.fold Left;

Either.swap : ∀ a b . Either a b -> Either b a;
Either.swap e = Either.fold Right Left e;

const x y = x;

first : ∀ a b . Pair a b -> a;
first p = Pair.fold const p;

rest : ∀ a b . Pair a b -> b;
rest p = Pair.fold (x y -> y) p;

1st = first;
2nd = rest `then` first;
3rd = rest `then` (rest `then` first);
4th = rest `then` (rest `then` (rest `then` first));
5th = rest `then` (rest `then` (rest `then` (rest `then` first)));
