identity : ∀ a . a -> a;
identity a = a;

const x y = x;

then : ∀ a b c . (a -> b) -> (b -> c) -> a -> c;
then f1 f2 x = f2 (f1 x);

flip : ∀ a b c . (a -> b -> c) -> b -> a -> c;
flip f b a = f a b;

first : ∀ a b . Pair a b -> a;
first p = Pair.fold const p;

rest : ∀ a b . Pair a b -> b;
rest p = Pair.fold (x y -> y) p;

1st = first;
2nd = rest `then` first;
3rd = rest `then` (rest `then` first);
4th = rest `then` (rest `then` (rest `then` first));
5th = rest `then` (rest `then` (rest `then` (rest `then` first)));

Remote.transfer : Node -> Remote Unit;
Remote.transfer node = Remote.at node unit;

Remote.map : ∀ a b . (a -> b) -> Remote a -> Remote b;
Remote.map f = Remote.bind (f `then` Remote.pure);

Vector.replicate : ∀ a . Number -> a -> Vector a;
Vector.replicate n a = Vector.map (const a) (Vector.range 0 n);

Remote.replicate : ∀ a . Number -> Remote a -> Remote (Vector a);
Remote.replicate n r = Remote.sequence (Vector.replicate n r);

Vector.fold-right : ∀ a b . (a -> b -> b) -> b -> Vector a -> b;
Vector.fold-right f z vs = Vector.fold-left (flip f) z (Vector.reverse vs);

Vector.fold-balanced : ∀ a . (a -> a -> a) -> a -> Vector a -> a;
Vector.fold-balanced plus zero vs = 
  let rec
    go plus zero vs = 
      if (Vector.size vs <= 2) 
         (Vector.fold-left plus zero vs)
         (let p = Vector.split vs;
              go plus zero (1st p) `plus` go plus zero (2nd p);;);
    go plus zero vs;; 
  ;

Remote.lift2 : ∀ a b c . (a -> b -> c) -> Remote a -> Remote b -> Remote c;
Remote.lift2 f a b = do Remote 
  a := a;
  b := b;
  pure (f a b);; 
  ;

Remote.traverse : ∀ a b . (a -> Remote b) -> Vector a -> Remote (Vector b);
Remote.traverse f vs =
  Vector.fold-balanced (Remote.lift2 Vector.concatenate)
                       (Remote.pure Vector.empty)
                       (Vector.map (f `then` Remote.map Vector.single) vs);

Remote.sequence : ∀ a . Vector (Remote a) -> Remote (Vector a);
Remote.sequence vs = 
  Vector.fold-balanced (Remote.lift2 Vector.concatenate)
                       (Remote.pure Vector.empty)
                       (Vector.map (Remote.map Vector.single) vs);

Optional.map : ∀ a b . (a -> b) -> Optional a -> Optional b;
Optional.map f = Optional.fold None (f `then` Some);

Optional.bind : ∀ a b . (a -> Optional b) -> Optional a -> Optional b;
Optional.bind f = Optional.fold None f;

Optional.pure : ∀ a . a -> Optional a;
Optional.pure = Some;

Either.map : ∀ a b c . (b -> c) -> Either a b -> Either a c;
Either.map f = Either.fold Left (f `then` Right);

Either.pure : ∀ a b . b -> Either a b;
Either.pure = Right;

Either.bind : ∀ a b c . (b -> Either a c) -> Either a b -> Either a c;
Either.bind = Either.fold Left;

Either.swap : ∀ a b . Either a b -> Either b a;
Either.swap e = Either.fold Right Left e;

