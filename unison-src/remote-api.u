type Either a b = Left a | Right b
type Status = Running | Finished | Canceled | Error Error
type Duration = Seconds Nat
-- type Abilities e = Abilities {e}

ability Remote loc where fork : loc {e} -> '{e} a ->{Remote loc} Future loc a
ability Error e where error : e ->{Error e} ()


type Future loc a = Future
  ('{Remote loc, Error Future.Error} a         -- join
  ,'{Remote loc} ()               -- cancel
  ,'{Remote loc} Status           -- status
  ,Duration ->{Remote loc} ())    -- keepalive (seconds 10)
type Future.Error = Unknown | Unreachable | Unresponsive | AbilityCheckFailure

Future.join : Future loc a ->{Remote loc, Error Future.Error} a
Future.join f = case f of Future.Future (j, c, s, k) -> !j

Future.cancel : Future loc a ->{Remote loc} ()
Future.cancel f = case f of Future.Future (j, c, s, k) -> !c

Future.status : Future loc a ->{Remote loc} Status
Future.status f = case f of Future.Future (j, c, s, k) -> !s

Future.keepalive : Future loc a -> Duration ->{Remote loc} ()
Future.keepalive f d = case f of Future.Future (j, c, s, k) -> k d

-- Ability.check : Abilities {a} -> Request {b} x -> Boolean
-- Ability.check = _


-- Remote.server : (loc {e} -> {e} a) -> {e} a
-- Remote.server computation =

type UnitLoc e = UnitLoc

-- Remote.runSequential : '{Remote UnitLoc, Error e} a -> Either e a
-- Remote.runSequential r =
--   step : Effect {Remote UnitLoc} a -> a
--   step r = case r of
--     {a} -> a
--     {Remote.fork loc t -> k} ->
--       join = Right !t
--       cancel = ()
--       status = Finished
--       keepalive d = ()
--       handle step in k (Future ('join, 'cancel, 'status, keepalive))
--   err : Effect {Error e} a -> Either e a
--   err e = case e of
--     {a} -> Right a
--     {Error.error t -> k} ->handle err in k (Left t)
--   handle err in handle step in !r

-- > Remote.runSequential

-- use Optional Some None
-- use Either Left Right
-- Either.join : Either a (Either a b) -> Either a b
-- Either.join e = case e of
--   Left a -> Left a
--   Right e -> e
--
-- parMergeSort : (a -> a -> Boolean) -> [a] ->{Remote UnitLoc, Error} [a]
-- parMergeSort (<) as =
--   -- merge : [a] -> [a] -> [a] -> [a]
--   merge z l r =
--     l0 = at 0 l
--     r0 = at 0 r
--     case (l0, r0) of
--       (None, _) -> z ++ r
--       (_, None) -> z ++ l
--       (Some l0, Some r0) ->
--         if l0 < r0
--         then merge (z `snoc` l0) (drop 1 l) r
--         else merge (z `snoc` r0) l (drop 1 r)
--   split = size as / 2
--   if split == 0 then as
--   else
--     fl = Remote.fork UnitLoc '(parMergeSort (<) (take split as))
--     fr = Remote.fork UnitLoc '(parMergeSort (<) (drop split as))
--     merge [] (Future.join fl) (Future.join fr)
