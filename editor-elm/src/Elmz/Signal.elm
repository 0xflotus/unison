module Elmz.Signal where

-- debugging
import Debug
import Elmz.Maybe
import Keyboard
import List
import Maybe
import Mouse
import Result
import Set exposing (Set)
import Signal exposing (..)
import Text
import Time
import Time exposing (Time)

{-| Accumulates into a list using `foldp` during regions where `cond`
    is `True`, otherwise emits the empty list. -}
accumulateWhen : Signal Bool -> Signal a -> Signal (List a)
accumulateWhen cond a = foldpWhen cond (::) [] a |> map List.reverse

{-| Alternate sending `input` through `left` or `right` signal transforms,
    merging their results. -}
alternate : (Signal (Maybe a) -> Signal c)
         -> (Signal (Maybe b) -> Signal c)
         -> Signal (Result a b)
         -> Signal c
alternate left right input =
  let l e = case e of Err e -> Just e
                      Ok _ -> Nothing
      r = Result.toMaybe
      ls = justs (l <~ input)
      rs = justs (r <~ input)
  in merge (left ls) (right rs)

{-| Count the number of events in the input signal. -}
count : Signal a -> Signal Int
count a = foldp (\_ n -> n + 1) 0 a

{-| Delay the input `Signal` by one unit. -}
delay : a -> Signal a -> Signal a
delay h s =
  let go a {prev,cur} = { cur = prev, prev = a }
  in foldp go { prev = h, cur = h } s
  |> map .cur

{-| Only emit when the input signal transitions from `True` to `False`. -}
downs : Signal Bool -> Signal Bool
downs s = filter not True s

{-| Emits an event whenever there are two events that occur within `within` time of each other. -}
doubleWithin : Time -> Signal s -> Signal ()
doubleWithin within s =
  let ts = map fst (Time.timestamp s)
      f t1 t2 = case t1 of
        Nothing -> False
        Just t1 -> if t2 - t1 < within then True else False
  in map2 f (delay Nothing (map Just ts)) ts
     |> filter identity False
     |> map (always ())

{-| Evaluate the second signal for its effects, but return the first signal. -}
during : Signal a -> Signal b -> Signal a
during a b = map2 always a (sampleOn (constant ()) b)

{-| Emit from `t` if `cond` is `True`, otherwise emit from `f`. -}
choose : Signal Bool -> Signal a -> Signal a -> Signal a
choose cond t f =
  let go cond a a2 = if cond then a else a2
  in go <~ cond ~ t ~ f

{-| Spikes `True` for one tick when `a` event fires, otherwise is `False`. -}
changed : Signal a -> Signal Bool
changed a =
  merge (always False <~ Time.delay 0 a)
        (always True <~ a)

clickLocations : Signal (Int,Int)
clickLocations = sampleOn Mouse.clicks (map2 always Mouse.position Mouse.clicks)

events : Signal a -> Signal (Maybe a)
events s =
  let f b a = if b then Just a else Nothing
  in map2 f (changed s) s

{-| Accumulate using `foldp` in between events generated by `reset`. Each `reset`
    event sets the `b` state back to `z`. -}
foldpBetween : Signal r -> (a -> b -> b) -> b -> Signal a -> Signal b
foldpBetween reset f z a =
  let f' a b = case a of
    Nothing -> z
    Just a -> f a b
  in foldp f' z (map (always Nothing) reset `merge` map Just a)

{-| Accumulate using `foldp` in between events generated by `reset`. Each `reset`
    event sets the `b` state back to the current value of `z`. -}
foldpBetween' : Signal r -> (a -> b -> b) -> Signal b -> Signal a -> Signal (Maybe b)
foldpBetween' reset f z a =
  let f' (a,z) b = case b of
    Nothing -> Just (f a z)
    Just b -> Just (f a b)
  in foldpBetween reset f' Nothing (map2 (,) a z)

{-| Accumulates using `foldp` during regions where `cond` is `True`,
    starting with the value `z`, otherwise emits `z`. -}
foldpWhen : Signal Bool -> (a -> b -> b) -> b -> Signal a -> Signal b
foldpWhen cond f z a =
  let go (cond,a) b = if cond then f a b else z
  in foldp go z (map2 (,) cond a)

{-| Like `foldpWhen`, but uses `z` as the starting value during 'live'
    regions, and emits `Nothing` when `cond` is `False`. -}
foldpWhen' : Signal Bool -> (a -> b -> b) -> Signal b -> Signal a -> Signal (Maybe b)
foldpWhen' cond f z a =
  let go (a,z) b = case b of Nothing -> Just (f a z)
                             Just b  -> Just (f a b)
  in foldpWhen cond go Nothing (map2 (,) a z)

fromMaybe : Signal a -> Signal (Maybe a) -> Signal a
fromMaybe = map2 Elmz.Maybe.fromMaybe

flattenMaybe : Signal (Maybe (Maybe a)) -> Signal (Maybe a)
flattenMaybe s = fromMaybe (constant Nothing) s

{-| Ignore any events of `Nothing`. -}
justs : Signal (Maybe a) -> Signal (Maybe a)
justs s = filter (Maybe.map (always True) >> Maybe.withDefault False) Nothing s

{-| Event which fires with the given `a` whenever the keycode is pressed down. -}
keyEvent : a -> Int -> Signal a
keyEvent k code = map (always k) (ups (Keyboard.isDown code))

{-| Event which fires with the given `a` whenever the keycodes are simultaneously pressed down. -}
keyChordEvent : a -> List Keyboard.KeyCode -> Signal a
keyChordEvent k codes =
  let
    hazTehCodez : Set Keyboard.KeyCode -> Bool
    hazTehCodez pressed =
      List.all (\k -> Set.member k pressed) codes
  in
    map (always k) (ups (map hazTehCodez Keyboard.keysDown))

map2r : (a -> b -> c) -> Signal a -> Signal b -> Signal c
map2r f a b = sampleOn b (map2 f a b)

{-| When the input is `False`, convert the signal to `Nothing`. -}
mask : Signal Bool -> Signal a -> Signal (Maybe a)
mask = map2 (\b a -> if b then Just a else Nothing)

{-| Replace the first occurence of the input signal with `a`. -}
replaceFirst : a -> Signal a -> Signal a
replaceFirst a0 s =
  let first = delay True (map (always False) s)
      f replace a = if replace then Debug.log ("replacing " ++ toString a) a0 else a
  in map2 f first s

{-| Repeat updates to a signal after it has remained steady for `t`
    elapsed time, and only if the current value tests true against `f`. -}
repeatAfterIf : Time -> number -> (a -> Bool) -> Signal a -> Signal a
repeatAfterIf time fps f s =
  let repeatable = map f s
      delayedRep = repeatable |> filter identity False |> Time.since time |> map not
      resetDelay = merge (always False <~ s) delayedRep
      repeats = Time.fpsWhen fps ((&&) <~ repeatable ~ dropRepeats resetDelay)
  in sampleOn repeats s

{-| Only emit updates of `s` when it settles into a steady state with
    no updates within the period `t`. Useful to avoid propagating updates
    when a value is changing too rapidly. -}
steady : Time -> Signal a -> Signal a
steady t s = sampleOn (Time.since t s |> filter not False) s

{-| Like `sampleOn`, but the output signal refreshes whenever either signal updates. -}
sampleOnMerge : Signal a -> Signal b -> Signal b
sampleOnMerge a b = map2 always b a

tagEvent : Signal a -> Signal b -> Signal (Maybe a, b)
tagEvent event behavior =
  let ae = merge (Just <~ event) (always Nothing <~ behavior)
  in zip ae behavior

transitions : Signal a -> Signal Bool
transitions = transitionsBy (==)

{-| `True` when the signal emits a value which differs from its previous value
    according to `same`, `False` otherwise. -}
transitionsBy : (a -> a -> Bool) -> Signal a -> Signal Bool
transitionsBy same s =
  let f prev cur = case prev of
    Nothing -> True
    Just prev -> same prev cur
  in map2 f (delay Nothing (map Just s)) s

{-| Alternate emitting `b` then `not b` with each event emitted by `s`,
    starting by emitting `b`. -}
toggle : Bool -> Signal a -> Signal Bool
toggle b s = foldp (\_ b -> not b) b s

tuple2 : Signal a -> Signal b -> Signal (a,b)
tuple2 s s2 = (,) <~ s ~ s2

{-| Spikes `False` for one tick when `a` event fires, otherwise is `True`. -}
unchanged : Signal a -> Signal Bool
unchanged a = map not (changed a)

{-| Only emit when the input signal transitions from `False` to `True`. -}
ups : Signal Bool -> Signal Bool
ups s = filter identity False s

zip : Signal a -> Signal b -> Signal (a,b)
zip = map2 (,)
