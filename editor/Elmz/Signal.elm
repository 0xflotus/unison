module Elmz.Signal where

import Either
import Either (Either)
import Elmz.Maybe
import Maybe
import Time

{-| Accumulates into a list using `foldp` during regions where `cond`
    is `True`, otherwise emits the empty list. -}
accumulateWhen : Signal Bool -> Signal a -> Signal [a]
accumulateWhen cond a = foldpWhen cond (::) [] a |> lift reverse

{-| Alternate sending `input` through `left` or `right` signal transforms,
    merging their results. -}
alternate : (Signal (Maybe a) -> Signal c)
         -> (Signal (Maybe b) -> Signal c)
         -> Signal (Either a b)
         -> Signal c
alternate left right input =
  let l = Either.either Just (always Nothing)
      r = Either.either (always Nothing) Just
      ls = justs (l <~ input)
      rs = justs (r <~ input)
  in merge (left ls) (right rs)

{-| Delay the input `Signal` by one unit. -}
delay : a -> Signal a -> Signal a
delay h s =
  let go a {prev,cur} = { cur = prev, prev = a }
  in foldp go { prev = h, cur = h } s
  |> lift .cur

{-| Emit from `t` if `cond` is `True`, otherwise emit from `f`. -}
choose : Signal Bool -> Signal a -> Signal a -> Signal a
choose cond t f =
  let go cond a a2 = if cond then a else a2
  in go <~ cond ~ t ~ f

{-| Spikes `True` for one tick when `a` event fires, otherwise is `False`. -}
changed : Signal a -> Signal Bool
changed a =
  merge (always False <~ Time.delay 0 a)
        (always True <~ a)

{-| Accumulate using `foldp` in between events generated by `reset`. Each `reset`
    event sets the `b` state back to `z`. -}
foldpBetween : Signal r -> (a -> b -> b) -> b -> Signal a -> Signal b
foldpBetween reset f z a =
  let f' a b = case a of
    Nothing -> z
    Just a -> f a b
  in foldp f' z (lift (always Nothing) reset `merge` lift Just a)

{-| Accumulate using `foldp` in between events generated by `reset`. Each `reset`
    event sets the `b` state back to the current value of `z`. -}
foldpBetween' : Signal r -> (a -> b -> b) -> Signal b -> Signal a -> Signal (Maybe b)
foldpBetween' reset f z a =
  let f' (a,z) b = case b of
    Nothing -> Just (f a z)
    Just b -> Just (f a b)
  in foldpBetween reset f' Nothing (lift2 (,) a z)

{-| Accumulates using `foldp` during regions where `cond` is `True`,
    starting with the value `z`, otherwise emits `z`. -}
foldpWhen : Signal Bool -> (a -> b -> b) -> b -> Signal a -> Signal b
foldpWhen cond f z a =
  let go (cond,a) b = if cond then f a b else z
  in foldp go z (lift2 (,) cond a)

{-| Like `foldpWhen`, but uses `z` as the starting value during 'live'
    regions, and emits `Nothing` when `cond` is `False`. -}
foldpWhen' : Signal Bool -> (a -> b -> b) -> Signal b -> Signal a -> Signal (Maybe b)
foldpWhen' cond f z a =
  let go (a,z) b = case b of Nothing -> Just (f a z)
                             Just b  -> Just (f a b)
  in foldpWhen cond go Nothing (lift2 (,) a z)

fromMaybe : Signal a -> Signal (Maybe a) -> Signal a
fromMaybe = lift2 Elmz.Maybe.fromMaybe

{-| Ignore any events of `Nothing`. -}
justs : Signal (Maybe a) -> Signal (Maybe a)
justs s = keepIf Maybe.isJust Nothing s

{-| Statefully transform the `a` signal, using `f`. -}
loop : (a -> s -> (b, s))
    -> s
    -> Signal a
    -> Signal (Maybe b)
loop f s a =
  let go a (_,s) = case f a s of (b,s) -> (Just b, s)
  in fst <~ foldp go (Nothing,s) a

{-| Emit updates to `s` only when it moves outside the current bin,
    according to the function `within`. Otherwise emit no update but
    take on the value `Nothing`. -}
quantize : (a -> r -> Bool) -> Signal r -> Signal a -> Signal (Maybe a)
quantize within bin s =
  let f range a = if a `within` range then Nothing else Just a
  in dropIf Maybe.isNothing Nothing (f <~ bin ~ s)

{-| Repeat updates to a signal after it has remained steady for `t`
    elapsed time, and only if the current value tests true against `f`. -}
repeatAfterIf : Time -> number -> (a -> Bool) -> Signal a -> Signal a
repeatAfterIf time fps f s =
  let repeatable = lift f s
      delayedRep = repeatable |> keepIf identity False |> since time |> lift not
      resetDelay = merge (always False <~ s) delayedRep
      repeats = fpsWhen fps ((&&) <~ repeatable ~ dropRepeats resetDelay)
  in sampleOn repeats s

{-| Only emit updates of `s` when it settles into a steady state with
    no updates within the period `t`. Useful to avoid propagating updates
    when a value is changing too rapidly. -}
steady : Time -> Signal a -> Signal a
steady t s = sampleOn (since t s |> dropIf identity False) s

{-| Alternate emitting `False` then `True` with each event emitted by `s`,
    starting by emitting `False`. -}
toggle : Signal a -> Signal Bool
toggle s =
  let t = lift (always True) s
  in xor <~ t ~ delay False t

{-| Spikes `False` for one tick when `a` event fires, otherwise is `True`. -}
unchanged : Signal a -> Signal Bool
unchanged a = lift not (changed a)

{-| Only emit when the input signal transitions from `False` to `True`. -}
ups : Signal Bool -> Signal Bool
ups s = keepIf identity False s

