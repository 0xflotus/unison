module Elmz.Signal where

import Text
import Mouse
-- debugging

import Elmz.Maybe
import List
import List ((::))
import Maybe
import Result
import Time
import Time (Time)
import Signal (..)

{-| Accumulates into a list using `foldp` during regions where `cond`
    is `True`, otherwise emits the empty list. -}
accumulateWhen : Signal Bool -> Signal a -> Signal (List a)
accumulateWhen cond a = foldpWhen cond (::) [] a |> map List.reverse

{-| Alternate sending `input` through `left` or `right` signal transforms,
    merging their results. -}
alternate : (Signal (Maybe a) -> Signal c)
         -> (Signal (Maybe b) -> Signal c)
         -> Signal (Result a b)
         -> Signal c
alternate left right input =
  let l e = case e of Err e -> Just e
                      Ok _ -> Nothing
      r = Result.toMaybe
      ls = justs (l <~ input)
      rs = justs (r <~ input)
  in merge (left ls) (right rs)

{-| Delay the input `Signal` by one unit. -}
delay : a -> Signal a -> Signal a
delay h s =
  let go a {prev,cur} = { cur = prev, prev = a }
  in foldp go { prev = h, cur = h } s
  |> map .cur

{-| Emit from `t` if `cond` is `True`, otherwise emit from `f`. -}
choose : Signal Bool -> Signal a -> Signal a -> Signal a
choose cond t f =
  let go cond a a2 = if cond then a else a2
  in go <~ cond ~ t ~ f

{-| Spikes `True` for one tick when `a` event fires, otherwise is `False`. -}
changed : Signal a -> Signal Bool
changed a =
  merge (always False <~ Time.delay 0 a)
        (always True <~ a)

events : Signal a -> Signal (Maybe a)
events s =
  let f b a = if b then Just a else Nothing
  in map2 f (changed s) s

{-| Accumulate using `foldp` in between events generated by `reset`. Each `reset`
    event sets the `b` state back to `z`. -}
foldpBetween : Signal r -> (a -> b -> b) -> b -> Signal a -> Signal b
foldpBetween reset f z a =
  let f' a b = case a of
    Nothing -> z
    Just a -> f a b
  in foldp f' z (map (always Nothing) reset `merge` map Just a)

{-| Accumulate using `foldp` in between events generated by `reset`. Each `reset`
    event sets the `b` state back to the current value of `z`. -}
foldpBetween' : Signal r -> (a -> b -> b) -> Signal b -> Signal a -> Signal (Maybe b)
foldpBetween' reset f z a =
  let f' (a,z) b = case b of
    Nothing -> Just (f a z)
    Just b -> Just (f a b)
  in foldpBetween reset f' Nothing (map2 (,) a z)

{-| Accumulates using `foldp` during regions where `cond` is `True`,
    starting with the value `z`, otherwise emits `z`. -}
foldpWhen : Signal Bool -> (a -> b -> b) -> b -> Signal a -> Signal b
foldpWhen cond f z a =
  let go (cond,a) b = if cond then f a b else z
  in foldp go z (map2 (,) cond a)

{-| Like `foldpWhen`, but uses `z` as the starting value during 'live'
    regions, and emits `Nothing` when `cond` is `False`. -}
foldpWhen' : Signal Bool -> (a -> b -> b) -> Signal b -> Signal a -> Signal (Maybe b)
foldpWhen' cond f z a =
  let go (a,z) b = case b of Nothing -> Just (f a z)
                             Just b  -> Just (f a b)
  in foldpWhen cond go Nothing (map2 (,) a z)

fromMaybe : Signal a -> Signal (Maybe a) -> Signal a
fromMaybe = map2 Elmz.Maybe.fromMaybe

flattenMaybe : Signal (Maybe (Maybe a)) -> Signal (Maybe a)
flattenMaybe s = fromMaybe (constant Nothing) s

{-| Ignore any events of `Nothing`. -}
justs : Signal (Maybe a) -> Signal (Maybe a)
justs s = keepIf (Maybe.map (always True) >> Maybe.withDefault False) Nothing s

{-| Statefully transform the `a` signal, using `f`. -}
loop : (a -> s -> (b, s))
    -> s
    -> Signal a
    -> Signal (Maybe b)
loop f s a =
  let go a (_,s) = case f a s of (b,s) -> (Just b, s)
  in fst <~ foldp go (Nothing,s) a

{-| Emit updates to `s` only when it moves outside the current bin,
    according to the function `within`. Otherwise emit no update but
    take on the value `Nothing`. -}
quantize : (a -> r -> Bool) -> Signal r -> Signal a -> Signal (Maybe a)
quantize within bin s =
  let f range a = if a `within` range then Nothing else Just a
  in dropIf (Maybe.map (always False) >> Maybe.withDefault True) Nothing (f <~ bin ~ s)

{-| Repeat updates to a signal after it has remained steady for `t`
    elapsed time, and only if the current value tests true against `f`. -}
repeatAfterIf : Time -> number -> (a -> Bool) -> Signal a -> Signal a
repeatAfterIf time fps f s =
  let repeatable = map f s
      delayedRep = repeatable |> keepIf identity False |> Time.since time |> map not
      resetDelay = merge (always False <~ s) delayedRep
      repeats = Time.fpsWhen fps ((&&) <~ repeatable ~ dropRepeats resetDelay)
  in sampleOn repeats s

{-| Only emit updates of `s` when it settles into a steady state with
    no updates within the period `t`. Useful to avoid propagating updates
    when a value is changing too rapidly. -}
steady : Time -> Signal a -> Signal a
steady t s = sampleOn (Time.since t s |> dropIf identity False) s

transitions : Signal a -> Signal Bool
transitions = transitionsBy (==)

{-| `True` when the signal emits a value which differs from its previous value
    according to `same`, `False` otherwise. -}
transitionsBy : (a -> a -> Bool) -> Signal a -> Signal Bool
transitionsBy same s =
  let f prev cur = case prev of
    Nothing -> True
    Just prev -> same prev cur
  in map2 f (delay Nothing (map Just s)) s

{-| Alternate emitting `False` then `True` with each event emitted by `s`,
    starting by emitting `False`. -}
toggle : Signal a -> Signal Bool
toggle s =
  let t = map (always True) s
  in xor <~ t ~ delay False t

tuple2 : Signal a -> Signal b -> Signal (a,b)
tuple2 s s2 = (,) <~ s ~ s2

{-| Spikes `False` for one tick when `a` event fires, otherwise is `True`. -}
unchanged : Signal a -> Signal Bool
unchanged a = map not (changed a)

{-| Only emit when the input signal transitions from `False` to `True`. -}
ups : Signal Bool -> Signal Bool
ups s = keepIf identity False s

zip : Signal a -> Signal b -> Signal (a,b)
zip = map2 (,)

main = Text.plainText << toString <~ changed Mouse.position
